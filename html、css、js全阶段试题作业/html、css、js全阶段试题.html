<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
    <title>document</title>
    <style type="text/css">
        *{
            padding: 0;
            margin: 0 10px;
        }
        #content div{
            font-size: 14px;
            text-align: center;
            color:#e9e9e9;
        }
        #nav{
            background: #e0e0e0;
        }
    
    
    </style>
     <script src="jquery-3.1.1.js"></script>
</head>
<body>


1 块级元素：<div></div>  ,< p></p>  ,< form></form>,  < ul></ul>,  <li></li> ,  <ol></ol>, <dl></dl>,    <form></form>,   <address></address>,  <fieldset></fieldset>,  <hr>, <menu></menu>,  <table></table>
   行内元素：<span></span>,   <strong></strong>,  < em></em>,  <br>,  <img >,  <input>,  <label></label>,  <select></select>,  <textarea></textarea>,  <cite></cite>,  
内联元素(inline element)
    
<a></a> - 锚点
<b></b> - 粗体(不推荐)
<br> - 换行
<em></em> - 强调
<font></font> - 字体设定(不推荐)
<i></i> - 斜体
<img> - 图片
<input> - 输入框
<label></label> - 表格标签
<select></select> - 项目选择
<small></small> - 小字体文本
<span></span> - 常用内联容器，定义文本内区块
<strike></strike> - 中划线
<strong></strong> - 粗体强调
<sub></sub> - 下标
<sup></sup> - 上标
<textarea></textarea> - 多行文本输入框
<tt></tt> - 电传文本
<u></u> - 下划线
    
内联元素（行内元素）内联元素(inline element)
* a - 锚点
*<abbr></abbr> - 缩写
* <acronym></acronym> - 首字
* b - 粗体(不推荐)
* <bdo></bdo> - bidi override
* <big></big> - 大字体
* <br> - 换行
* <cite></cite> - 引用
* <code></code> - 计算机代码(在引用源码的时候需要)
* <dfn></dfn> - 定义字段
* em - 强调
* font - 字体设定(不推荐)
* i - 斜体
* img - 图片
* input - 输入框
* <kbd></kbd> - 定义键盘文本
* label - 表格标签
* <q></q> - 短引用
* <s></s> - 中划线(不推荐)
* <samp></samp> - 定义范例计算机代码
* select - 项目选择
* small - 小字体文本
* span - 常用内联容器，定义文本内区块
* strike - 中划线
* strong - 粗体强调
* sub - 下标
* sup - 上标
* textarea - 多行文本输入框
* tt - 电传文本
* u - 下划线
* <va></va>r - 定义变量

块元素(block element)
* <address></address> - 地址

* <blockquote></blockquote> - 块引用
* <center></center> - 举中对齐块
* <dir></dir> - 目录列表
* <div></div> - 常用块级容易，也是css layout的主要标签
* <dl></dl> - 定义列表
* <fieldset></fieldset> - form控制组
* <form></form> - 交互表单
* <h1></h1> - 大标题
* <h2></h2> - 副标题
* <h3></h3> - 3级标题
* <h4></h4> - 4级标题
* <h5></h5> - 5级标题
* <h6></h6> - 6级标题
* <hr> - 水平分隔线
* <isindex></isindex> - input prompt
* <menu></menu> - 菜单列表
* <noframes></noframes> - frames可选内容，（对于不支持frame的浏览器显示此区块内容
* <noscript></noscript> - ）可选脚本内容（对于不支持script的浏览器显示此内容）
* <ol></ol> - 排序表单
* <p></p> - 段落
* <pre></pre> - 格式化文本
* <table></table> - 表格
* <ul></ul> - 非排序列表

    
可变元素
可变元素为根据上下文语境决定该元素为块元素或者内联元素。

* <applet></applet> - java applet
* <button></button> - 按钮
* <del></del> - 删除文本
* <iframe></iframe> - inline frame
* <ins></ins> - 插入的文本
* <map></map> - 图片区块(map)
* <object></object> - object对象
* <script></script> - 客户端脚本    
       
2,css引入方式：
    1).最常用的，引入样式表，在样式表中编写样式，引入方式如下：
        <link href="css/style.css" rel="stylesheet" type="text/css">
    2).在Html头部用<style></style>包起来，在这里面编写样式：
        <style type="text/css">
        	*{
        		padding: 0;margin: 0
        	}
        </style>
    3).在标签里面直接编写行内样式。

             <div  style="color: #333"><div>
 
    4). 使用@import引入CSS文件
   使用@import引入CSS文件有两种方式，一种可以放在页面中的<STYLE>...</STYLE> 中,用法如下：
　  @import url(index2.css);
   另外也可以放在CSS文件中使用，用法如下：
 　@import "sub.css";
   使用用@import引入CSS可以很方便的引入外部文件的CSS代码，方便维护和规划。但是每多引入一个CSS文件，就会对服务器增加一次连接请求，当访问量较大时，需在维护性和性能上进行权衡。       
            
3.web标准：   web标准是一系列标准的集合，将页面的结构（html、xml),表现(css)和行为(js,dom)各自独立实现，包含的是一种思想、一种方式，并非一种形式；     
        
    。网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括XHTML和XML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。这些标准大部分由万维网联盟（外语缩写：W3C）起草和发布，也有一些是其他标准组织制订的标准，比如ECMA（European Computer Manufacturers Association）的ECMAScript标准。  
  <script type="text/javascript">   
4.简化css代码：  
     // *{
     //        padding: 0;
     //        margin: 0 10px;
     //    }
     //    #content div{
     //        font-size: 14px;
     //        text-align: center;
     //        color:#e9e9e9;
     //    }
     //    #nav{
     //        background: #e0e0e0;
     //    }
    
5.默认的margin：8px;    
    
6.html页面中，orange颜色的区域宽度302px;  距离页面左边和上边的距离分别是
    40px、10px;
        
7.用css、html编写一个两列布局的网页，要求右侧宽度为200px,左侧自动扩展。
// <!DOCTYPE html>
// <html lang="en">
// <head>
//     <meta charset="utf-8">
//     <title>document</title>
//     <style type="text/css">
//     .wrapper{
//     		position: relative;
//     		width: 1000px;
//     		height: 500px;
//     		margin: 0 auto;
//     		border:1px solid #3c3c3c;
//     	}
//     	.pos1{
//     		float: left;
//     		width: auto;

//     		color: #fff;
//     		text-align: center;
//     		background-color: orange;

//     	}
//     	.pos2{
//     		float: right;
//     		width: 200px;
//     		height: 50px;line-height: 50px;
//     		color: #fff;
//     		background-color: red;
//     		text-align: center;

//     	}
// </style>
// </head>
// <body>
//     <div class="wrapper">
//   	   <div class="pos1">aaaaaaaaaaaa<br>aaaaaaaaaa</div>
//   	   <div class="pos2">bbbbb</div>
//      </div> 
// </body>
// </html> 
       
       
       
8.如何居中一个浮动元素？    
// 1). <!DOCTYPE html>
//<html lang="en">
//<head>
//   <meta charset="utf-8">
//    <title>Document</title>
//    <style type="text/css">
//    *{
//        padding: 0;
//        margin: 0;
//        list-style: none;
//    }
//    #wrapper{
//        position: relative;
//        width: 300px; 
//        height: 500px;
//        margin: 0 auto;
//    }
//    #my-defined{
//        position: absolute;
//        width: 300px;
//        height: 500px;
//    }
//    </style>
//</head>
//<body>
//<div id="wrapper">
//   
//        <div id="my-defined"></div>
//</div>
//
//</body>
//</html>   

//2).    
//    <!DOCTYPE html>
//<html lang="en">
//<head>
//   <meta charset="utf-8">
//    <title>Document</title>
//    <style type="text/css">
//    *{
//        padding: 0;
//        margin: 0;
//        list-style: none;
//    }
//   
//    #my-defined{
//        position: absolute;
//        left: 50%;
//        margin-left: -150px;
//        width: 300px;
//        height: 500px;
//        background-color: red;
//    }
//    </style>
//</head>
//<body>
//
//   
//        <div id="my-defined"></div>
//
//
//</body>
//</html>
//        
9.略

10.form表单中method属性常用那些值，他们的区别是什么？
method:GET POST等；
一、get和post定义
form元素的method属性用来指定发送form的http方法；
使用get时，form数据集被附加到form元素的action属性所指定的URL后面；
使用post时，form数据集被包装在请求的body中并被发送。

使用get提交方式，生成URL：user.do?loginId=abc
get仅仅是拼接一个URL，然后直接向服务区请求数据，需要提交给服务器的数据集包含在URL中。
使用post提交方式，生成URL：user.do
post会把form的数据集，即loginId=abc这个键值对包装在请求的body中，发给服务器，然后向服务器请求数据。
二、get和Post的区别
1、安全性
如果用get提交一个验证用户名和密码的form，一般认为是不安全的，因为用户名和密码将出现在URL上，进而出现在浏览器的历史记录中。
显然，在对安全性有要求的情况下，应该使用post。
2、编码
get只能向服务器发送ASCII字符，而post则可以发送整个ISO 10646中的字符。
get和post对应的enctype属性有区别。enctype有两个值，默认值为application/x-www-form-urlencoded（在发送前编码所有字符）
另一个是multipart/form-data（用于文件上传）只能用于post。
3、提交数据的长度。
IE将请求的URL长度限制为2083个字符，从而限制了get提交的数据长度，如果URL超出了这个限制，提交form时IE不会有任何反映。
4、缓存
由于一个get得到的结果直接对应到一个URL，所以get的结果页面有可能被浏览器缓存，而post一般不能。
5、引用和SEO 

可以用一个URI引用一个get的结果页面，而post的结果则不能，所以必然不能被搜索引擎搜到。

最本质的区别：
1、Get是用来从服务器上获得数据，而post是用来向服务器上传递数据
如果采用Post方法，浏览器将会按照下面两步来发送数据。
首先浏览器将action属性中指定的表单处理服务器建立联系，一旦建立连接之后，浏览器就会按分段传输的方法将数据发送给服务器。
在服务器端，一旦Post样式的应用程序开始执行时，就应该从一个标志位置读取参数，而一旦读到参数，在应用程序能够使用这些表单值以前，必须对这些参数进行解码，用户特定的服务器会明确指定应用程序应该如何接受这些参数。
采用Get方法：
浏览器会直接与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据，然后直接在一个传输步骤中发送所有的表单数据。
2、Get将表单中数据的按照variable=value的形式，添加到action所指向的URL后面，并且两者使用“?”连接，而各个变量之间使用“&”连接；Post是将表单中的数据放在form的数据体中，按照变量和值相对应的方式，传递到action所指向URL。
       

11.如何去掉ul>li结构中li前面的圆点？去除圆点后每个li前面会有空余，如何解决？
 *{
    padding: 0;
    margin: 0;
    list-style: none;
}    

 12.typeof 运算符把类型信息当作字符串返回。typeof 返回值有六种可能： "number," "string," 
"boolean," "object," "function," 和 "undefined."      
       

13.var arr=["goole","microsoft","oracle","阿里",.....]
arr.join('');

14.代码注释：
html：<!--  -->
css: /**/
js://
        
15.用js生成dom结构：
var oDiv = document.createElement('div');
        oDiv.className = "example";
var oP = document.createElement('p');
        oP.className = "slogan";
        oP.innerText = "姬成，你真帅！"
oDiv.appendChild(oP);
document.body.appendChild(oDiv);
       
16.要为一个元素绑定一个事件，如点击事件，写出各个浏览器都兼容的方法。     
function addEvent(elem,type,handler) {

	if(elem.addEventListener) {
		elem.addEventListener(type,handler,false);
	}else if(elem.attachEvent) {
		elem['temp'+type+handler] = handler;
		elem['temp'+type] = function () {
			elem['temp'+ type+handler].call(elem);
		}
		elem.attachEvent('on'+type,elem['temp'+type]);
	}else{
		elem['on'+type] = handler;
	}
}

function handler() {
处理函数。。。。
}
       
17.call和apply方法的用途，和区别。  
用途：call和apply修改了this的当前作用对象间接调用函数。
 区别：apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。
如 func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])      
       
18.封装一个Ajax；
	//封装好的 Ajax ：打开方式 地址 是否异步 回调函数 提交数据
	function Ajax (method,address,flag,callBacks,data) {
		var xhr = null;
		if(window.XMLHttpRequest) {
			xhr = new XMLHttpRequest();
		} else {
			xhr = new ActiveXObject('Microsoft.XMLHTTP');
		}
		if (method == 'get') {
			xhr.open('get',address,flag);
			xhr.send();		
		}else if (method == 'post') {
			xhr.open('post',address,flag);
			xhr.setRequestHeader('content-type','application/x-www-form-urlencoded');
			xhr.send(data);			
		}
		
		xhr.onreadystatechange = function() {
			if ( xhr.readyState == 4 ) {
				if ( xhr.status == 200 ) {
					callBacks(xhr.responseText);
				} else {
					alert('出错了,Err：' + xhr.status);
				}
			}
			
		}	
	}
        
19.数组去重：
 Array.prototype.unique = function()
{
	var n = [this[0]]; //结果数组
	for(var i = 1; i < this.length; i++) //从第二项开始遍历
	{
		//如果当前数组的第i项在当前数组中第一次出现的位置不是i，
		//那么表示第i项是重复的，忽略掉。否则存入结果数组
		if (this.indexOf(this[i]) == i) n.push(this[i]);
	}
	return n;
}
20.如今有一个ul,里面有十亿个li,要求点击li触发点击事件，弹出li里面的内容；     
       
   ul.onclick = function(e) {
	var event = e||window.event;
	var target = event.targrt||srcElement;
	  // 　if(target.nodeName.toLowerCase() == 'li'){
　 　　　　　　
　　　　　　　  alert(target.innerHTML);
// 　　　　}

}    
       
21.阻止事件冒泡和事件默认事件：
封装事件的时候返回false；
封装取消冒泡事件的函数 stopBubble(event);
  function stopBubble(e){
	if(e.stopPropagation) {
		e.stopPropagation();
	}else {
		e.cancelBubble = true;
	}
}     


阻止默认事件的函数 cancelHandler(event);
return false;
event.preventDefault();
event.returnvalue =false;
        
function cancelHandler(e) {
	if(e.preventDefault) {
		e.preventDefault();
	}else {
		e.returnvalue = false;
	}
}

        
22.什么是DOm?
    Dom->Document Object Model
 2)dom定义啦表示和修改文档所需的对象、这些对象的行为和属性以及这些对象之间的关系。Dom对象即为宿主对象，由浏览器厂商定义，用来操作html和css功能的一类对象的集合
       。也有人称Dom是HTMl以及XML的标准编程接口。
       
23.请利用Javascript取行间样式，要求兼容各个浏览器

function getStyle(obj,name){
    if(obj.currentStyle){
        //IE
        return obj.currentStyle[name];
    }else{
        //Firefox、Chrome
        return getComputedStyle(obj,false)[name];
    }
};

24.运行text() new text()的结果是什么？
   var a = 5;
function text() {
a = 0;
alert(a);
alert(this.a);
var a;
alert(a);
        }

text();//0 5 0
new text();//0 undefined 0;
       
25.有字符串"aaabbbcccdddeeefga",转换成连续不重复的字符串（用正则表达式）    
var str ="aaabbbcccdddeeefga";
String.prototype.quchong = function() {
var reg =/(.)\1+/g;
return this.replace(reg,'$1');
    
        }

    str.quchong(); 
26.一连串连续的数字，用正则表达式实现打点功能。
var a = 10000000000;a = a.toString();
var a = a.split("").reverse().join("");

var reg =/([0]{3})[0]{0}/g;

console.log(reg.exec(a)); alert(a.replace(reg,"$1\.").split("").reverse().join(""));

27.写出运算结果；
alert(typeof(a));//undefined
alert(typeof(undefined));//undefined
alert(typeof(NaN));//number
alert(typeof(null));//object
var a="123abc";
alert(typeof(+a));//number
alert(typeof(!!a));//boolean
alert(typeof(a+""));//string
alert(1=="1");//true
alert(NaN==NaN);//false
alert(NaN==undefined);//false
alert("11"+11);//1111
alert(1==="1");//false
alert(parseInt("123abc"));//123
var num = 123123.345789;
alert(num.toFixed(3));//123123.346
    
28.打印当前年月日时分秒；
alert(new Date())
new Date().getDate(); new Date().getMonth()+1; new Date().getFullYear(); new Date().getHours(); new Date().getMinutes(); new Date().getSeconds();

29.css中font-size设置的是高还是宽,px,em是相对值还是绝对值？

设置的是字体中字符框的高度；实际的字符字形可能比这些框高或矮（通常会矮）。
px：为像素单位。它是显示屏上显示的每一个小点，为显示的最小单位。它是一个绝对尺寸单位；
em：它是描述相对于应用在当前元素的字体尺寸，多理解父级设定font-size的尺寸，所以它也是相对长度单位。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸；
一般浏览器字体大小默认为16px，则2em == 32px；
.一旦父级元素有设定字体大小, em前面数值x就相当于父级元素字体乘以x%
.相对最临近父级元素,且可以一直往下叠加
    .
30.有html结构下，求他们之间的距离。
<div style = "background-color:red;margin:0 0 100px 0;">123<div>
<div style = "background-color:red;margin:200px 0 0 0">234</div>
距离：200px;

31.自定义函数构造函数创建对象的原理。


function foo() {
this(or that) = {};
this.xxxx = xxxx;
.....
return this(that)
        }
var Foo = new foo();


32.原型链实现继承的方式；
function foo() {
this.name = apple;
        }
function bar() {
this.grade = 100;
return this.name;
        }
bar.prototype = new foo();
bar.prototype.getscore = function() {
return this.grade;
        }

33.深度克隆：

Object.prototype.clone = function(obj) {
	var str,newobj = obj.constructor===Array?[] : {};
    if(typeof obj!=="object" || obj===null) {
    	return obj;
    }

    else if(window.JSON) {
    	str = JSON.stringify(obj);
      newobj = JSON.parse(str);
    	 // var newobj = Object.create(obj);
    }

else {
    	for(var i in obj) {
          if(!obj1.hasOwnProperty(key))
       {
          if(typeof obj[key] =="object"&&obj[key]!=null)
    		newobj[i] = typeof obj[i]==="object"? cloneObj(obj[i]):obj[i];
    	}
            }
    }
   return newobj;
}

34.描述预编译：四部曲：
1.创建AO对象（函数作用域）
2.找形参和变量声明，将变量和形参名作为AO属性名，值为undefined;即变量声明提升；
3将形参和实参统一；
4.找函数声明，值赋予函数体，即函数定义提升；


35.js语言特点；解释性语言--跨平台；单线程，javascript兼容于ECMA标准，也称为ECMAScript;
        
36.主流浏览器，以及相应内核，浏览器分为几部分。
IE                          Trident
Mozilla Firefox             Gecko
Kongqueror                  KHTML(Linux)    
Chrome、Safari              Webkit
Safari                      Blink
Opera                      Presto
浏览器组成：
1. 用户界面－包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分
2. 浏览器引擎－用来查询及操作渲染引擎的接口
3. 渲染引擎－用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来
4. 网络－用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作
5. UI 后端－用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口
6. JS解释器－用来解释执行JS代码
7. 数据存储－属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术

37.js时间线；
1、创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = 'loading'。
2、遇到link外部css，创建线程加载，并继续解析文档。
3、遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。
4、遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。
对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()）
5、遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。
6、当文档解析完成，document.readyState = 'interactive'。
7、文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,但同样禁止使用document.write()）;
8、document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。
9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = 'complete'，window对象触发load事件。
10、从此，以异步响应方式处理用户输入、网络事件等。

38.异步加载js
javascript 异步加载 的 三种方案
1.defer 异步加载，但要等到dom文档全部解析完才会 被执行。只有IE能用。
2.async 异步加载，加载完就执行，async只能加载外 部脚本，不能把js写在script 标签里。
1.2 执行时也不阻塞页面
3.创建script，插入到DOM中，加载完毕后callBack，有按需加载，延迟加载，预加载。

39.var a = (10*3-4/2 + 1) % 2;
b = 3;
b%= a+3;
console.log(a++);
console.log(-b);
//1 -3
40. 
// <ul>
// <li>a</li> 
// <li>a</li> 
// <li>a</li> 
// <li>a</li>
// </ul> 
使用原生的js,addEventListener,给每个li元素绑定事件，输出他们的顺序。
var list = document.getElementsByTagName('li');
for(i = 0; i < list.length; i++) {
            list[i].addEventListener ? list[i].addEventListener("mouseover",function(){list[i].className = i + "li"}, false) : list[i].attachEvent("onmouseover", function(){list[i].className = i + "li"});
    }

41.一个字符串由a-z组成，找出第一个只出现一次的字母。
function findindex(str) {
	var newstr = [],len = str.length;
	for(var i = 0; i < len;i++){
		for(var j = i+1; j < len;j++){
			if(str[i]==str[j])
				break;
		}
         if(j>len) {
         	return str[i];
         }
	}
}
console.log(findindex("aaabbbsssddghhhh"));

42.var name = "222"; 
var a = {  
        name : "111",
        say : function () {
            console.log(this.name);            
        }        
    } 

    var fun = a.say;
    fun();//222
    a.say();//111
    var b = {
     name : "333", 
    say : function (fun){ 
        fun();
            }
         }       
         b.say(a.say);//222
        b.say = a.say; 
        b.say();//333

43..var str = “你成哥真帅！”;  
   str.length = 3;
    console.log(str);//你成哥真帅！
    // 可以访问但是不能更改
 44.用多种方法创建对象。
 1.对象字面量。
 var foo = {
 	one:1,
 	two:2,
 	third:function(){alert(3);}
 }
foo.third();
2.创建Object实例
var bar = new Object();
bar.one = 1;
bar.two = 2;
bar.third = function() {
	alert(3);
}
对象创建模式：

1.工厂模式：
function foo(a,b,c) {
	var bar = {};
	bar.a = a;
	bar.b = b,
	bar.c = c;
	bar.show = function() {
		alert(bar.a);
	}
	return bar;
}

var newfoo = new foo(1,2,3);
newfoo.show();
2.构造函数模式
function foo(one,two,three) {
	this.one = one;
	this.two = two;
	this.three = three;
	this.show = function() {
		alert(this.one);
	}
	return this;
}
var newfoo = new foo();
foo.show();
3原型模式
function foo() {}
foo.prototype.one = 1;
foo.prototype.two = 2;
foo.prototype.three = 3;
foo.prototype.show = function(){
	alert(one);
}
var newfoo = new foo();
foo.show();

4.构造-原型组合模式。
function foo(one,two,three) {
	this.one = one;
	this.two = two;
	this.three = three;
}
foo.prototype.show = function(){
alert(one);
};

模块模式
1,function foo(){
	//声明依赖
	var specs = {
	var a = 1,
	b = 2,
	//私有属性和方法
	c = function(){}...;
	//var变量定义结束
};
	// 特权方法
	this.getele = function() {
		return specs;
	}

	myobj = {
		getele: function() {
		return specs;
	}
	}
	return {
		getele:function() {
		return specs;
	}
	}
}

foo.prototype =(function() {
	//私有成员
	var browser = "mobie webkit";

	return{
		getBrowser:function() {
			return browser;
		}
	}
}())

2,var foo;
(function() {
	//声明依赖
	var a = 1,
	b = 2,constr,
	//私有属性和方法
	c = function(){}...;
	//var变量定义结束
	//可选的一次性初始化
	for(){}....


	//公有API
	//1.
	return {
		a:function(){},
		b:function(){},
		c:c
		// 更多方法和属性
	}
	//2
	//公有API-构造函数
constr = function(){},
//公有API-构造原型
constr.prototype = function(){
	constructor:....
	。。。。。
}
return constr;
)()}


45.用命名空间函数，加即时函数，声明依赖，私有和特权成员；

46.枚举一个对象中所有的自有属性：

	var getMyPropertyEle = function(obj) {
		if(typeof obj !='object') return;
		var props = [];
		for(var prop in obj) {
			if(obj.hasOwnProperty(prop)){
				props.push(prop);
			}
		}
		return props;
	}
var obj = {
	'x':1.
	'y':2
}
var pro = getMyPropertyEle(obj);
console.log(pro.length);
console.log(pro.join(','));

47.arr.sort();

48.es5严格模式的使用：
1.“use strict”
2.全局严格模式
局部函数内严格模式（推荐）
3.就是一行字符串，不会对不兼容严格模式的浏览器产生影响。
不支持with,arguments.callee,func.caller,变量赋值前必须声明，局部 this必须被赋值(Person.call(null/undefined) 赋值什么就是什么),拒 绝重复属性和参数

49.选择html元素节点的几种方法，以及他们各自的兼容性问题
document代表整个文档
document.getElementById() //元素id 在Ie8以下的浏览器，不区分id大小写，而且也返回匹配 name属性的元素
.getElementsByTagName() // 标签名
getElementByName(); //，需注意，只有部分标签name可生效（表单，表单元素，img，iframe）
.getElementsByClassName() // 类名 -> ie8和ie8以下的ie版本中没有，可以多个class一起
.querySelector() // css选择器 在ie7和ie7以下的版本中没有
.querySelectorAll() // css选择器 在ie7和ie7以下的版本中没有

// 遍历节点树：
// parentNode -> 父节点 (最顶端的parentNode为#document);
// childNodes -> 子节点们
// firstChild -> 第一个子节点
// lastChild -> 最后一个子节点
// nextSibling->后一个兄弟元素 previousSibling->前一个兄弟元素
基于元素节点树的遍历
parentElement -> 返回当前元素的父元素节点 (IE不兼容)
children -> 只返回当前元素的元素子节点
node.childElementCount  === node.children.length当前元素节点的子元素节点个数(IE不兼容)
firstElementChild -> 返回的是第一个元素节点(IE不兼容)
lastElementChild -> 返回的是最后一个元素节点(IE不兼容)
nextElementSibling / previousElementSibling ->返回后一个/前一个兄弟元素节点（IE不兼容)


50.节点的类型
元素节点 —— 1
属性节点 —— 2
文本节点 —— 3
注释节点 —— 8
document  —— 9
DocumentFragment  —— 11 
获取节点类型 nodeType 

51.鼠标事件的触发顺序。以及如何实现右键的事件监听。

1.单击操作：MouseDown > Click > Mouseup;
2双击操作:MouseDown Click Mouseup Dblclick MouseDown Mouseup
3.mouseover > mouseout mouseenter>mouseleaver
4键盘事件触发顺序：keydown - > keypress - > keyup;
// mouseover与mouseenter
// 不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。
// 只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。
// mouseout与mouseleave
// 不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。
// 只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。
5如何实现右键的事件监听:  //去掉默认的contextmenu事件，否则会和右键事件同时出现。
           document.oncontextmenu = function(e){

               if(e.preventDefault) {
		e.preventDefault();
	}else {
		e.returnvalue = false;
	}
           };
    // 处理鼠标右键事件 
function rightKey(e) {
	var e = e || window.event;
	if(e.button =="0") {
		//左键callback()执行。封装各种事件什么的。
	}
	else{
		//右键callback();
	}
}

52.JSON.parse();  string — > json
JSON.stringify(); json — > string


53.BOM对象: Window, History,Navigator,Screen, Location等
Location对象
location.hash
“#”后是对浏览器操作的，对服务器 无效，实际发出的请求也不包含”#” 后面的部分
“#”被算作历史记录;

54.position定位的值有什么区别？如果有不能兼容的问题如何解决？

css中position定位有四个属性，分别是：static、fixed、relative、absolute。
其中，static是默认值，未脱离文档流，元素的位置即按照文档结构的顺序进行定位排序；

fixed是固定定位，和absolute定位不同的是，设置为固定定位的元素不会随页面滚动而改变位置，所以经常用在登录框和导航中。 
//如果fixed不能兼容，用absolute做兼容：
// <div style="position:absolute;background:red;width:50px;height:50px;id="box">
js代码：
window.onscroll = function() {
	var box = document.getElementById('box');
	var t = document.documentElement.scrollTop||document.body.scrollTop;
	box.style.top += t +"px";
}


relative，相对定位，相对元素原来的位置进行定位。脱离文档流。relative的偏移是基于对象的margin的左上侧的。

absolute，绝对定位，需要一个父元素且设计relative or absolute作为参考，并且父元素设置不能为static。如果无父元素则默认为body元素。脱离文档流。
55.
ul{  

    width: 400px;
    height: 40px;
    border:1px solid #3c3c3c;
    list-style-type:none;  
    padding:0px;
     } 
  ul>li{

    float:left;width: 100px;
    height: 40px;
    background-color: red;
    margin:0 0 0 10px;
     }
     <ul><li></li><li></li><li></li> </ul>  

56.用权重表示css选择的优先级顺序：
important > 内联 > ID > 类 > 标签 | 伪类 | 属性选择 > 伪对象 > 继承 > 通配符
第一等：代表内联样式，如: style=””，权值为1000。
第二等：代表ID选择器，如：#content，权值为100。
第三等：代表类，伪类和属性选择器，如.content :link	[attr]	[title]权值为10。
第四等：代表类型选择器和伪元素选择器，如div p，:first-line 权值为1。
第五等：* 0；

57，display 的值和含义：其中常用的的有none、inline、block、inline-block。分别的意思是：
1、none： 元素不会显示，而且改元素现实的空间也不会保留。但有另外一个 visibility: hidden， 是保留元素的空间的。
2、inline： display的默认属性。将元素显示为内联元素，元素前后没有换行符。我们知道内联元素是无法设置宽高的，所以一旦将元素的display 属性设为 inline， 设置属性height和width是没有用的。此时影响它的高度一般是内部元素的高度（font-size）和padding。

3、block： 将元素将显示为块级元素，元素前后会带有换行符。设置为block后，元素可以设置width和height了。“元素独占一行。”
4、inline-block：行内块元素。这个属性值融合了inline 和 block 的特性，即是它既是内联元素，又可以设置width和height。

58，写一个输入框，带有js功能，鼠标聚焦提示信息消息，失去焦点时显示信息。
<input type="text" name = "input" id = "input" value = "" class="in" onfocus = "if(value=='')alert('请输入信息')" onblur = "if(value=='')alert('请输入信息'); else {var a=this.value;alert(a);}"> 
59..function fn(a, b) { arguments[0] = 1; console.log(a); } fn(2,1); //1,arguments对象是比较特别的一个对象，是当前函数的一个内置属性，arguments和形参值都存在的情况下，两者值是同步的，无值的情形值不会得以同步，且可以同步修改形参；
60.̶将下列变量名转换成小驼峰式
my-ﬁrst-name —> myFirstName    var str = "my-first-name"; 
var reg = /\-([A-Za-z])/g;
str.replace(reg,function($0,$1){
	return $1.toUpperCase();
});

61.请将形如aaaabbbbb的字符串调换成bbbbbaaaa的形式
var reg = /(([A-Za-z])\2+)(([A-Za-z])\4+).{0}/g;
var str = "aaaabbbb";
str.replace(reg,'$3$1');

62.


    </script>
    
        
</body>
</html>